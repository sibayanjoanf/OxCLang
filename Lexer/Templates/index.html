<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OxCLang Compiler</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
</head>
<body>
    <div class="header">
        <h1>OxC Lang</h1>
        <div class="icons">
            <button id="themeSwitch" class="theme-switch">
                <i id="theme-icon" class="fas fa-sun"></i>
            </button>
            <button id="runButton" class="run-button">
                <span class="play-icon">&#9654;</span>
                Run Code
            </button>
        </div>
    </div>

    <div class="container">
        <div class="editor-section">
            <div class="editor-wrapper">
                    <div id="lineNumbers" class="line-numbers">1</div>
                    <div id="coloredCode" class="colored"></div>
                    <textarea id="codeInput" placeholder="Start typing your code here..." spellcheck="false" wrap="off"></textarea>
            </div>
        </div>

        <div class="output-section">
            <div class="section-header">
                <span>LEXEME</span>
                <span>TOKEN</span>
            </div>
            <div id="tokenOutput"></div>
        </div>
    </div>

    <div class="error-section">
        <div class="error-header">Output Code</div>
        <div id="errorOutput"></div>
    </div>

    <script>
        const codeInput = document.getElementById('codeInput');
        const highlight = document.getElementById('coloredCode');
        const lineNumbers = document.getElementById('lineNumbers');
        const tokenOutput = document.getElementById('tokenOutput');
        const errorOutput = document.getElementById('errorOutput');
        const runButton = document.getElementById('runButton');
        const themeSwitch = document.getElementById('themeSwitch');
        const themeIcon = document.getElementById('theme-icon');

        // auto-indent with Tab key
        codeInput.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                e.preventDefault();
                
                const start = codeInput.selectionStart;
                const end = codeInput.selectionEnd;
                const value = codeInput.value;
                
                // Insert 4 spaces for a tab
                codeInput.value = value.substring(0, start) + '    ' + value.substring(end);
                codeInput.selectionStart = codeInput.selectionEnd = start + 4;
                codeInput.dispatchEvent(new Event('input'));
            }
            
        //     // Auto-close brackets, parentheses, and braces
        //     const pairs = {
        //         '{': '}',
        //         '(': ')',
        //         '[': ']',
        //         '"': '"',
        //         '\'': '\''
        //     };
            
        //     if (pairs[e.key]) {
        //         e.preventDefault();
                
        //         const start = codeInput.selectionStart;
        //         const end = codeInput.selectionEnd;
        //         const value = codeInput.value;
        //         const opening = e.key;
        //         const closing = pairs[e.key];
                
        //         codeInput.value = value.substring(0, start) + opening + closing + value.substring(end);
        //         codeInput.selectionStart = codeInput.selectionEnd = start + 1;
        //         codeInput.dispatchEvent(new Event('input'));
        //     }
        });

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function updateLineNumbers() {
            const lines = codeInput.value.split('\n');
            const lineCount = lines.length;
            
            let lineNumbersHtml = '';
            for (let i = 1; i <= lineCount; i++) {
                lineNumbersHtml += i + '\n';
            }
            lineNumbers.textContent = lineNumbersHtml;
        }

        function displayResults(allTokens, lexicalErrors, syntaxErrors) {
            const validTokens = allTokens.filter(token => !token.is_error);

            if (validTokens.length === 0) {
                tokenOutput.innerHTML = '<div style="color: #474747; padding: 10px;">No tokens yet. Start typing in the editor...</div>';
            } else {
                tokenOutput.innerHTML = validTokens.map((token, i) => {
                    const errorClass = token.is_error ? 'token-error' : '';
                    return `
                        <div class="token">
                            <span class="token-line">${i + 1}</span>
                            <span class="token-value">${escapeHtml(token.value)}</span>
                            <span class="token-type">${token.type}</span>
                        </div>
                    `;
                }).join('');
            }

            let errorHTML = '';

            // Lexical Errors
            if (lexicalErrors && lexicalErrors.length > 0) {
                // errorHTML += '<div style="font-weight: bold; padding: 5px; border-bottom: 1px solid #ccc;">Lexical Errors:</div>';
                errorHTML += lexicalErrors.map((error) => `
                    <div class="error-item">
                        <span class="lexical-impostor" style="font-weight: bold;">Lexical Impostor:</span>
                        <span class="error-details">${escapeHtml(error.value)}</span>
                        <span class="error-location">[Line ${error.line}, Col ${error.column}]</span>
                    </div>
                `).join('');
            }
            
            // Syntax Errors
            if (syntaxErrors && syntaxErrors.length > 0) {
                // errorHTML += '<div style="font-weight: bold; padding: 5px; border-bottom: 1px solid #ccc; margin-top: 10px;">Syntax Errors:</div>';
                errorHTML += syntaxErrors.map((error) => `
                    <div class="error-item">
                        <span class="syntactical-impostor" style="color: #8d1d1d; font-weight: bold;">Syntactical Impostor:</span>
                        <span class="error-details">${escapeHtml(error.message)}</span>
                        ${error.line > 0 ? `<span class="error-location">[Line ${error.line}, Col ${error.column}]</span>` : ''}
                    </div>
                `).join('');
            }

            if ((!lexicalErrors || lexicalErrors.length === 0) && (!syntaxErrors || syntaxErrors.length === 0)) {
                errorHTML = '<div style="color: #474747; padding: 10px;">No errors detected.</div>';
            }
            
            errorOutput.innerHTML = errorHTML;
        }

        function syncHighlight() {
            const codeText = codeInput.value;
            highlight.innerHTML = colorCode(codeText);

            highlight.style.left = (80 - codeInput.scrollLeft) + 'px';
            highlight.style.top = (40 - codeInput.scrollTop) + 'px';
        }

        // Sync scroll between line numbers and textarea
        codeInput.addEventListener('scroll', () => {
            lineNumbers.scrollTop = codeInput.scrollTop;
            highlight.style.left = (80 - codeInput.scrollLeft) + 'px';
            highlight.style.top = (40 - codeInput.scrollTop) + 'px';
        });

        // Update line numbers on input
        codeInput.addEventListener('input', (e) => {
            updateLineNumbers();

            clearTimeout(typingTimer);
            typingTimer = setTimeout(() => {
                runLexer();
            }, typingDelay);
        });

        let typingTimer;
        const typingDelay = 200;

        codeInput.addEventListener('input', (e) => {
            clearTimeout(typingTimer);
            typingTimer = setTimeout(() => {
                runLexer();
            }, typingDelay);
        });

        codeInput.addEventListener('input', syncHighlight);
        
        // run button'ed
        runButton.addEventListener('click', () => {
            runParser();
            console.log("girl");
        });

        // document.addEventListener('keydown', (e) => {
        //     if (e.key === 'F10') {
        //         e.preventDefault();
        //         runCode();
        //     }
        //     
        // });

        codeInput.addEventListener('input', () =>{
            const codeText = codeInput.value;
            highlight.innerHTML = colorCode(codeText);
        });

        function runLexer() {
            const code = codeInput.value;
            
            fetch('/tokenize', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ code: code })
            })
            .then(response => response.json())
            .then(data => {
                displayResults(data.all_tokens, data.errors, []);
            })
            .catch(error => {
                console.error('Error:', error);
                errorOutput.innerHTML = '<div class="error-item"><span style="color: #8d1d1d;">Error connecting to server</span></div>';
            });
        }

        function runParser() {
            const code = codeInput.value;
            
            fetch('/parse', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ code: code })
            })
            .then(response => response.json())
            .then(data => {
                let syntaxErrors = data.syntax_errors || [];

                if (!data.success && data.error && syntaxErrors.length === 0) {
                    syntaxErrors = [{message: data.error, line: 0, column: 0}];
                }
                
                displayResults(data.all_tokens, data.lexical_errors || [], syntaxErrors);
                
                if (data.success) {
                    // ✅ Parsing successful
                    console.log('✅ Parsing successful!');
                    console.log('AST:', data.ast);
                }                    
                // } else {
                //     // ❌ Parsing failed - ADD syntax error to existing errors
                //     console.log('❌ Parsing failed:', data.error);
                    
                //     // Extract line and column from error message
                //     const errorMsg = data.error;
                //     const lineMatch = errorMsg.match(/line (\d+)/);
                //     const colMatch = errorMsg.match(/column (\d+)/);
                    
                //     let locationStr = '';
                //     if (lineMatch && colMatch) {
                //         locationStr = `<span class="error-location">[Line ${lineMatch[1]}, Col ${colMatch[1]}]</span>`;
                //     }
                    
                //     // Create syntax error HTML
                //     const syntaxErrorHTML = `
                //         <div class="error-item">
                //             <span class="syntactical-impostor" style="color: #8d1d1d; font-weight: bold;">Syntactical Impostor:</span>
                //             <span class="error-details">${escapeHtml(errorMsg)}</span>
                //             ${locationStr}
                //         </div>
                //     `;
                    
                //     // APPEND syntax error to existing content (don't replace)
                //     // Check if there are already errors displayed
                //     if (errorOutput.innerHTML.includes('No lexical errors detected')) {
                //         // Replace the "no errors" message with the syntax error
                //         errorOutput.innerHTML = syntaxErrorHTML;
                //     } else {
                //         // Add syntax error AFTER lexical errors
                //         errorOutput.innerHTML += syntaxErrorHTML;
                //     }
                // }
            })
            .catch(error => {
                console.error('Error:', error);
                errorOutput.innerHTML = '<div class="error-item"><span style="color: #8d1d1d;">Error connecting to server</span></div>';
                
                // if (errorOutput.innerHTML.includes('No lexical errors detected')) {
                //     errorOutput.innerHTML = connectionErrorHTML;
                // } else {
                //     errorOutput.innerHTML += connectionErrorHTML;
                // }
            });
        }

        function escapeHTML(str) {
            return str
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/\//g, "&#x2F;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#x27;")
                .replace(/=/g, "&#x3D;");
        }

        function colorCode(code) {
            let escaped = escapeHTML(code);

            // data types :D
            escaped = escaped.replace(/\b(int|float|char|string|bool|vacuum|gust|yuh|naur)\b/g,
                '<span class="dataTypes">$1</span>'
            );

            // function words
            escaped = escaped.replace(/\b(air|atmosphere|sizeOf|toBool|toChar|toFall|toFloat|toInt|toRise|toString|waft|gasp|horizon)\b/g,
                '<span class="functions">$1</span>'
            );

            // constants
            escaped = escaped.replace(/\b(universal|wind)\b/g,
                '<span class="consy">$1</span>'
            );

            // other rw
            escaped = escaped.replace(/\b(if|else|elseif|stream|case|diffuse|echo|cycle|do|resist|flow|inhale|exhale)\b/g,
                '<span class="rw">$1</span>'
            );

            // numbers
            escaped = escaped.replace(/\b\d+\b/g,
                '<span class="num">$&</span>'
            );

            console.log(escaped);
            return escaped;
        }

        themeSwitch.addEventListener('click', () => {
            const body = document.body;
            body.classList.toggle('light-theme');
            
            if (body.classList.contains('light-theme')) {
                themeIcon.classList.remove('fa-sun');
                themeIcon.classList.add('fa-moon');
            } else {
                themeIcon.classList.remove('fa-moon');
                themeIcon.classList.add('fa-sun');
            }
        });

        updateLineNumbers();
        displayResults([], []);
    </script>
</body>
</html>
